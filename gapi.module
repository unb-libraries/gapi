<?php

/**
 * @file
 * A general purpose Drupal API integration module. This allows
 * other modules a set of standard tools for integrating third
 * party services into Drupal.
 */

/**
 * Retrieve an array of all APIs supported via the gapi module.
 *
 * @return array
 *   An array of info details for all apis supported
 *   by gapi.
 */
function gapi_get_apis_info() {
  $gapi_infos = &drupal_static(__FUNCTION__, array());

  if (empty($gapi_infos)) {
    $cached = cache_get('gapi_infos');
    if (!empty($cached)) {
      $gapi_infos = $cached->data;
    }
    else {
      $gapi_infos = module_invoke_all('gapi_info');
      cache_set('gapi_infos', $gapi_infos);
    }
  }

  return $gapi_infos;
}

/**
 * Lazy load the api interface.
 *
 * @param string $api_name
 *   The machine name of the api to connect to. Typically
 *   this will be the module name.
 * @param bool $reset
 *   If the API is in an offline state, this function will
 *   not try and reconnect unless this is set to TRUE.
 *   CRON will periodically try and reconnect so generally
 *   no need to set this variable.
 *
 * @return API|boolean
 *   Access object to talk to the API.
 *   This will be empty if connection failed.
 *
 * @throws GAPIUnavailableException
 *   If the API is unavaliable then this function will
 *   throw this exception which should be caught in all
 *   instances this function is called.
 */
function gapi_get_api($api_name, $reset = FALSE) {
  $apis = &drupal_static(__FUNCTION__, array());

  // Check on the availbility of the service.
  if (!$reset && variable_get($api_name . '-UNAVAILABLE', FALSE)) {
    throw new GAPIUnavailableException($api_name, $api_name . ' is currently unavailable', FALSE);
  }

  if (empty($apis[$api_name])) {
    try {
      $apis[$api_name] = module_invoke($api_name, 'gapi');
    }
    catch (Exception $e) {
      watchdog_excepton('gapi', $e);
      throw new GAPIUnavailableException($api_name, $e->getMessage());
    }
  }

  return $apis[$api_name];
}

/**
 * Mark a service as unavailable.
 */
function gapi_unavailable($api_name, $extra = 'None') {
  // Mark this API as unavailable to stop future connection attempts.
  variable_set($api_name . '-UNAVAILABLE', TRUE);

  // Log the problem.
  watchdog($api_name, '@api_name has been marked as unavailable with a fail count of :fails', array(
    '@api_name' => $api_name,
    ':fails' => variable_get($api_name . '-FAIL-COUNT', 0)), WATCHDOG_ERROR);

  // Inform the powers that be.
  _gapi_send_status_email($api_name, $extra);
}

/**
 * Mark a service as available.
 */
function gapi_available($api_name, $extra = 'None') {
  // Mark this API as available to allow future connection attempts.
  variable_set("{$api_name}-UNAVAILABLE", FALSE);

  // Log this triumph.
  watchdog($api_name, '@api_name is back again. It was switched off after recording :fails fails', array('@api_name' => $api_name, ':fails' => variable_get($api_name . '-FAIL-COUNT')), WATCHDOG_NOTICE);

  // Inform the powers that be.
  _gapi_send_status_email($api_name, $extra);
}

/**
 * Send an email to admin when enabling or disabling the api.
 *
 * @param string $api_name
 *   The name of the api
 * @param string $extra
 *   Extra details to add to the email.
 */
function _gapi_send_status_email($api_name, $extra = '') {

  // Determine the current status of the api.
  $status = variable_get("{$api_name}-UNAVAILABLE", FALSE) ? 'unavailable' : 'available';

  // Decide who to email to tell them about this.
  $email = variable_get("{$api_name}-FAIL-EMAIL", NULL);
  if (empty($email)) {
    // Use user 1's email.
    $email = user_load(1)->mail;
  }

  // Send an email.
  $details = array(
    'fails' => variable_get("{$api_name}-FAIL-COUNT", 0),
    'api_name' => $api_name,
    'extra' => $extra,
  );
  drupal_mail('gapi', "gapi_api_{$status}", $email, language_default(), $details);
}

/**
 * Implements hook_mail().
 */
function gapi_mail($key, &$message, $params) {
  if ($key == 'gapi_api_unavailable' || $key == 'gapi_api_available') {
    $message['subject'] = "{$params['api_name']} has been marked as {$key}";
    $message['body'][] = "{$params['api_name']} has been marked as {$key}.";
    $message['body'][] = "Timeouts recorded: {$params['fails']}";
    $message['body'][] = "Any extra info: {$params['extra']}";
  }
}

/**
 * Implements hook_cron().
 *
 * Check all disabled apis and switch them on if they are OK.
 */
function gapi_cron() {
  foreach (gapi_get_apis_info() as $api_name => $api_info) {
    if (variable_get("{$api_name}-UNAVAILABLE", FALSE)) {
      try {

        // See if we can connect.
        $api = gapi_get_api($api_name, TRUE);
        if (!empty($api) && $api instanceof GAPIInterface && $api->gapiCheckConnection()) {
          // If we get here, all is well with the api.
          gapi_available($api_name, "CRON switched {$api_name} on.");
        }

      }
      catch (Exception $e) {
        watchdog('gapi', 'CRON tried to switch on @api_name but failed with message: !message', array('@api_name' => $api_name, '!message' => nl2br($e->getMessage())), WATCHDOG_ERROR);
      }
    }
    else {
      // Reset the fail counter every cron run.
      variable_set("{$api_name}-FAIL-COUNT", 0);
    }
  }
}

/**
 * GAPIUnavailableException thrown when there is a
 * timeout connecting to the db.
 */
class GAPIUnavailableException extends Exception {

  /**
   * GAPIUnavailableException.
   *
   * This exceptuon occurs when there are problems communicating with
   * a service. If the fault counter is incremented past the global maximum
   * the service is marked as unavailabe and no PHP threads will try and
   * communicate with it until it comes back.
   *
   * @param string $api_name
   *   The name of the API.
   * @param string $message
   *   The message for the exception.
   * @param bool $increment_fault_counter
   *   TRUE if this should increment the fault counter.
   */
  public function __construct($api_name, $message = '', $increment_fault_counter = TRUE) {
    if ($increment_fault_counter) {
      $fails = variable_get("{$api_name}-FAIL-COUNT", 0);
      $fails++;
      variable_set("{$api_name}-FAIL-COUNT", $fails);
      if ($fails > variable_get("{$api_name}-FAIL-COUNT-CUTOFF", 5)) {
        gapi_unavailable($api_name, $message);
      }
    }

    parent::__construct($message);
  }
}
